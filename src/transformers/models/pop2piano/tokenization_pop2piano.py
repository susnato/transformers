# coding=utf-8
# Copyright 2023 The Pop2Piano Authors and The HuggingFace Inc. team.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Tokenization class for Pop2Piano."""

import json
import os
from typing import List, Optional, Tuple, Union

import librosa
import numpy as np
import pretty_midi
import soundfile as sf
import torch

from ...tokenization_utils import PreTrainedTokenizer
from ...utils import logging


logger = logging.get_logger(__name__)

VOCAB_FILES_NAMES = {
    "tokenizer_file": "tokenizer.json",
}

PRETRAINED_VOCAB_FILES_MAP = {
    "tokenizer_file": {
        "susnato/pop2piano_dev": "https://huggingface.co/susnato/pop2piano_dev/blob/main/tokenizer.json",
    },
}


class Pop2PianoTokenizer(PreTrainedTokenizer):
    """
    Constructs a Pop2Piano tokenizer. This tokenizer does not require training. The `Pop2PianoTokenizer.__call__()`
    method can only process one sequence at a time.

    This tokenizer inherits from [`PreTrainedTokenizer`] which contains most of the main methods. Users should refer
    to: this superclass for more information regarding those methods. However the code does not allow that and only
    supports composing from various genres.

    Args:
        tokenizer_file (`str`):
            Path to the tokenizer file which contains token-ids such as `TOKEN_SPECIAL`, `DEFAULT_VELOCITY`,
             `PAD`, `EOS`.
        vocab_size_special (`int`, *optional*, defaults to 4):
            Number of special values.
        vocab_size_note (`int`, *optional*, defaults to 128):
            This represents the number of Note Values. Note values indicate a pitch event for one of the MIDI pitches.
            But only the 88 pitches corresponding to piano keys are actually used.
        vocab_size_velocity (`int`, *optional*, defaults to 2):
            Number of Velocity tokens.
        vocab_size_time (`int`, *optional*, defaults to 100):
            This represents the number of Beat Shifts. Beat Shift [100 values] Indicates the relative time shift within
            the segment quantized into 8th-note beats(half-beats).
    """

    vocab_files_names = VOCAB_FILES_NAMES
    pretrained_vocab_files_map = PRETRAINED_VOCAB_FILES_MAP

    def __init__(
        self,
        tokenizer_file,
        vocab_size_special: int = 4,
        vocab_size_note: int = 128,
        vocab_size_velocity: int = 2,
        vocab_size_time: int = 100,
        n_bars: int = 2,
        **kwargs,
    ):
        super().__init__(
            **kwargs,
        )
        with open(tokenizer_file, "rb") as t_file:
            self.tokenizer_config = json.load(t_file)

        self.TIE = self.tokenizer_config["TIE"]
        self.EOS = self.tokenizer_config["EOS"]
        self.PAD = self.tokenizer_config["PAD"]
        self.TOKEN_NOTE = self.tokenizer_config["TOKEN_NOTE"]
        self.TOKEN_TIME = self.tokenizer_config["TOKEN_TIME"]
        self.TOKEN_SPECIAL = self.tokenizer_config["TOKEN_SPECIAL"]
        self.TOKEN_VELOCITY = self.tokenizer_config["TOKEN_VELOCITY"]
        self.DEFAULT_VELOCITY = self.tokenizer_config["DEFAULT_VELOCITY"]

        self.vocab_size_special = vocab_size_special
        self.vocab_size_note = vocab_size_note
        self.vocab_size_velocity = vocab_size_velocity
        self.vocab_size_time = vocab_size_time
        self.n_bars = n_bars

    @property
    def vocab_size(self):
        return self.vocab_size_special + self.vocab_size_note + self.vocab_size_time + self.vocab_size_velocity

    def get_vocab(self):
        return self.tokenizer_config

    def _convert_id_to_token(self, token, time_idx_offset):
        """Decodes the tokens generated by the transformer"""

        if token >= (self.vocab_size_special + self.vocab_size_note + self.vocab_size_velocity):
            type, value = self.TOKEN_TIME, (
                (token - (self.vocab_size_special + self.vocab_size_note + self.vocab_size_velocity)) + time_idx_offset
            )
        elif token >= (self.vocab_size_special + self.vocab_size_note):
            type, value = self.TOKEN_VELOCITY, (token - (self.vocab_size_special + self.vocab_size_note))
            value = int(value)
        elif token >= self.vocab_size_special:
            type, value = self.TOKEN_NOTE, (token - self.vocab_size_special)
            value = int(value)
        else:
            type, value = self.TOKEN_SPECIAL, token
            value = int(value)

        return [type, value]

    def _convert_token_to_id(self, token, token_type):
        if token_type == self.TOKEN_TIME:
            return self.vocab_size_special + self.vocab_size_note + self.vocab_size_velocity + token
        elif token_type == self.TOKEN_VELOCITY:
            return self.vocab_size_special + self.vocab_size_note + token
        elif token_type == self.TOKEN_NOTE:
            return self.vocab_size_special + token
        elif token_type == self.TOKEN_SPECIAL:
            return token
        else:
            return -1

    def relative_batch_tokens_to_midi(
        self,
        tokens,
        beatstep,
        beat_offset_idx=None,
        bars_per_batch=None,
        cutoff_time_idx=None,
    ):
        """Converts tokens to midi"""

        beat_offset_idx = 0 if beat_offset_idx is None else beat_offset_idx
        notes = None
        bars_per_batch = 2 if bars_per_batch is None else bars_per_batch

        N = len(tokens)
        for n in range(N):
            _tokens = tokens[n]
            _start_idx = beat_offset_idx + n * bars_per_batch * 4
            _cutoff_time_idx = cutoff_time_idx + _start_idx
            _notes = self.relative_tokens_to_notes(
                _tokens,
                start_idx=_start_idx,
                cutoff_time_idx=_cutoff_time_idx,
            )

            if len(_notes) == 0:
                pass
            elif notes is None:
                notes = _notes
            else:
                notes = np.concatenate((notes, _notes), axis=0)

        if notes is None:
            notes = []
        midi = self.notes_to_midi(notes, beatstep, offset_sec=beatstep[beat_offset_idx])
        return midi, notes

    def relative_tokens_to_notes(self, tokens, start_idx, cutoff_time_idx=None):
        # decoding If the first token is an arranger
        if tokens[0] >= (
            self.vocab_size_special + self.vocab_size_note + self.vocab_size_velocity + self.vocab_size_time
        ):
            tokens = tokens[1:]

        words = [self._convert_id_to_token(token, time_idx_offset=0) for token in tokens]

        if hasattr(start_idx, "item"):
            """if numpy or torch tensor"""
            start_idx = start_idx.item()

        current_idx = start_idx
        current_velocity = 0
        note_onsets_ready = [None for i in range(self.vocab_size_note + 1)]
        notes = []
        for type, number in words:
            if type == self.TOKEN_SPECIAL:
                if number == self.EOS:
                    break
            elif type == self.TOKEN_TIME:
                current_idx += number
                if cutoff_time_idx is not None:
                    current_idx = min(current_idx, cutoff_time_idx)

            elif type == self.TOKEN_VELOCITY:
                current_velocity = number
            elif type == self.TOKEN_NOTE:
                pitch = number
                if current_velocity == 0:
                    # note_offset
                    if note_onsets_ready[pitch] is None:
                        # offset without onset
                        pass
                    else:
                        onset_idx = note_onsets_ready[pitch]
                        if onset_idx >= current_idx:
                            # No time shift after previous note_on
                            pass
                        else:
                            offset_idx = current_idx
                            notes.append([onset_idx, offset_idx, pitch, self.DEFAULT_VELOCITY])
                            note_onsets_ready[pitch] = None
                else:
                    # note_on
                    if note_onsets_ready[pitch] is None:
                        note_onsets_ready[pitch] = current_idx
                    else:
                        # note-on already exists
                        onset_idx = note_onsets_ready[pitch]
                        if onset_idx >= current_idx:
                            # No time shift after previous note_on
                            pass
                        else:
                            offset_idx = current_idx
                            notes.append([onset_idx, offset_idx, pitch, self.DEFAULT_VELOCITY])
                            note_onsets_ready[pitch] = current_idx
            else:
                raise ValueError

        for pitch, note_on in enumerate(note_onsets_ready):
            # force offset if no offset for each pitch
            if note_on is not None:
                if cutoff_time_idx is None:
                    cutoff = note_on + 1
                else:
                    cutoff = max(cutoff_time_idx, note_on + 1)

                offset_idx = max(current_idx, cutoff)
                notes.append([note_on, offset_idx, pitch, self.DEFAULT_VELOCITY])

        if len(notes) == 0:
            return []
        else:
            notes = np.array(notes)
            note_order = notes[:, 0] * 128 + notes[:, 1]
            notes = notes[note_order.argsort()]
            return notes

    def notes_to_midi(self, notes, beatstep, offset_sec=None):
        """Converts notes to midi"""

        new_pm = pretty_midi.PrettyMIDI(resolution=384, initial_tempo=120.0)
        new_inst = pretty_midi.Instrument(program=0)
        new_notes = []
        if offset_sec is None:
            offset_sec = 0.0

        for onset_idx, offset_idx, pitch, velocity in notes:
            new_note = pretty_midi.Note(
                velocity=velocity,
                pitch=pitch,
                start=beatstep[onset_idx] - offset_sec,
                end=beatstep[offset_idx] - offset_sec,
            )
            new_notes.append(new_note)
        new_inst.notes = new_notes
        new_pm.instruments.append(new_inst)
        new_pm.remove_invalid_notes()
        return new_pm

    def get_stereo(self, pop_y, midi_y, pop_scale=0.99):
        """Generates stereo audio using `pop audio(`pop_y`)` and `generated midi audio(`midi_y`)`"""

        if len(pop_y) > len(midi_y):
            midi_y = np.pad(midi_y, (0, len(pop_y) - len(midi_y)))
        elif len(pop_y) < len(midi_y):
            pop_y = np.pad(pop_y, (0, -len(pop_y) + len(midi_y)))
        stereo = np.stack((midi_y, pop_y * pop_scale))
        return stereo

    def _to_np(self, tensor):
        """Converts pytorch tensor to np.ndarray."""
        if isinstance(tensor, np.ndarray):
            return tensor
        elif isinstance(tensor, torch.Tensor):
            return tensor.cpu().numpy()
        else:
            raise ValueError("dtype not understood! Please use either torch.Tensor or np.ndarray")

    def save_vocabulary(self, save_directory: str, filename_prefix: Optional[str] = None) -> Tuple[str]:
        """
        Args:
        Saves the tokenizer's vocabulary dictionary to the provided save_directory.
            save_directory (`str`):
                A path to the directory where to saved. It will be created if it doesn't exist.
            filename_prefix (`Optional[str]`, *optional*):
                A prefix to add to the names of the files saved by the tokenizer.
        """
        if not os.path.isdir(save_directory):
            logger.error(f"Vocabulary path ({save_directory}) should be a directory")
            return

        tokenizer_file = os.path.join(
            save_directory, (filename_prefix + "-" if filename_prefix else "") + VOCAB_FILES_NAMES["tokenizer_file"]
        )
        with open(tokenizer_file, "w", encoding="utf-8") as f:
            f.write(json.dumps(self.tokenizer_config))

        return (tokenizer_file,)

    def __call__(
        self,
        relative_tokens: Union[np.ndarray, torch.Tensor],
        beatsteps: Union[np.ndarray, torch.Tensor],
        ext_beatstep: Union[np.ndarray, torch.Tensor],
        raw_audio: Union[np.ndarray, List[float], List[np.ndarray]],
        sampling_rate: int,
        mix_sampling_rate=None,
        save_path: str = None,
        audio_file_name: str = None,
        save_midi: bool = False,
        save_mix: bool = False,
        click_amp: float = 0.2,
        stereo_amp: float = 0.5,
        add_click: bool = False,
    ):
        r"""
        This is the `__call__` method for `Pop2PianoTokenizer`. It converts the tokens generated by the transformer to
        midi_tokens and also saves the `"generated midi audio"` and `"stereo-mix"`.

        Args:
            relative_tokens ([`~utils.TensorType`]):
                Output of `Pop2PianoConditionalGeneration` model.
            beatsteps ([`~utils.TensorType`]):
                beatsteps returned by `Pop2PianoFeatureExtractor.__call__`
            ext_beatstep ([`~utils.TensorType`]):
                ext_beatstep returned by `Pop2PianoFeatureExtractor.__call__`
            raw_audio (`np.ndarray`, `List`):
                Denotes the raw_audio.
            sampling_rate (`int`):
                Denotes the Sampling Rate of `raw_audio`.
            mix_sampling_rate (`int`, *optional*):
                Denotes the Sampling Rate for `stereo-mix`.
            audio_file_name (`str`, *optional*):
                Name of the file to be saved.
            save_path (`str`, *optional*):
                Path where the `stereo-mix` and `midi-audio` is to be saved.
            save_midi (`bool`, *optional*):
                Whether to save `midi-audio` or not.
            save_mix (`bool`, *optional*):
                Whether to save `stereo-mix` or not.
            add_click (`bool`, *optional*, defaults to `False`):
                Constructs a `"click track"`.
            click_amp (`float`, *optional*, defaults to 0.2):
                Amplitude for `"click track"`.
        Returns:
            `pretty_midi.pretty_midi.PrettyMIDI` : returns pretty_midi object.
        """

        relative_tokens = self._to_np(relative_tokens)
        beatsteps = self._to_np(beatsteps)
        ext_beatstep = self._to_np(ext_beatstep)

        if (save_midi or save_mix) and save_path is None:
            raise ValueError("If you want to save any mix or midi file then you must define save_path.")

        if save_path and (not save_midi and not save_mix):
            raise ValueError(
                "You are setting save_path but not saving anything, use save_midi=True to "
                "save the midi file and use save_mix to save the mix file or do both!"
            )

        mix_sampling_rate = sampling_rate if mix_sampling_rate is None else mix_sampling_rate

        if save_path is not None:
            if os.path.isdir(save_path):
                midi_path = os.path.join(save_path, f"midi_output_{audio_file_name}.mid")
                mix_path = os.path.join(save_path, f"mix_output_{audio_file_name}.wav")
            else:
                raise ValueError(f"Is {save_path} a directory?")

        pm, notes = self.relative_batch_tokens_to_midi(
            tokens=relative_tokens,
            beatstep=ext_beatstep,
            bars_per_batch=self.n_bars,
            cutoff_time_idx=(self.n_bars + 1) * 4,
        )
        for n in pm.instruments[0].notes:
            n.start += beatsteps[0]
            n.end += beatsteps[0]

        if save_midi:
            pm.write(midi_path)
            print(f"midi file saved at {midi_path}!")

        if save_mix:
            if mix_sampling_rate != sampling_rate:
                raw_audio = librosa.core.resample(raw_audio, orig_sr=sampling_rate, target_sr=mix_sampling_rate)
                sampling_rate = mix_sampling_rate
            if add_click:
                clicks = librosa.clicks(times=beatsteps, sr=sampling_rate, length=len(raw_audio)) * click_amp
                raw_audio = raw_audio + clicks
            pm_raw_audio = pm.fluidsynth(sampling_rate)
            stereo = self.get_stereo(raw_audio, pm_raw_audio, pop_scale=stereo_amp)

            sf.write(
                file=mix_path,
                data=stereo.T,
                samplerate=sampling_rate,
                format="wav",
            )
            print(f"stereo-mix file saved at {mix_path}!")

        return pm
